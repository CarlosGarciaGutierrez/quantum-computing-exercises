
Jupyter Notebook
Ejercicios introducción ProjectQ (autosaved) Current Kernel Logo

Python 3

    File
    Edit
    View
    Insert
    Cell
    Kernel
    Widgets
    Help

Ejercicios de introducción a ProjectQ

1) Escribe una función de nombre hello_entangled_world que reciba un engine y devuelva el estado de los qubits después de ejecutar el circuito de la figura.

import projectq

from projectq.ops import *

​

def hello_entangled_world(eng):

    

    q = eng.allocate_qureg(2)

        

    H | q[0]

    CNOT | (q[0], q[1])

    

    All(Measure) | q

    

    eng.flush()

    

    return q

2) Usando el simulador, ejecuta el circuito 1000 veces y calcula la frecuencia de cada una de las cuatro posibles salidas.

def circuito1(numEjecuciones):

    resultados = {"00":0, "01":0, "10":0, "11":0}

​

    for _ in range(numEjecuciones):

    

        q = hello_entangled_world(eng)

        valor = str(int(q[0])) + str(int(q[1]))

        resultados[valor] += 1

    

    print(resultados)

    print("Frecuencia 00: " + str(resultados["00"]/numEjecuciones))

    print("Frecuencia 01: " + str(resultados["01"]/numEjecuciones))

    print("Frecuencia 10: " + str(resultados["10"]/numEjecuciones))

    print("Frecuencia 11: " + str(resultados["11"]/numEjecuciones))

​

eng = projectq.MainEngine()

​

circuito1(1000)

{'00': 509, '01': 0, '10': 0, '11': 491}
Frecuencia 00: 0.509
Frecuencia 01: 0.0
Frecuencia 10: 0.0
Frecuencia 11: 0.491

3) Repite el cálculo de frecuencias, pero esta vez en el ordenador de la IBM Quantum Experience

import projectq.setups.ibm

from projectq.backends import IBMBackend

​

eng = projectq.MainEngine(IBMBackend(use_hardware=True, num_runs=1024,verbose=True,

                                     device='ibmqx4', num_retries=30),

                          engine_list=projectq.setups.ibm.get_engine_list())

​

circuito1(1000)

The device is offline (for maintenance?). Use the simulator instead or try again later.

---------------------------------------------------------------------------
DeviceOfflineError                        Traceback (most recent call last)
<ipython-input-5-11354251686e> in <module>
      6                           engine_list=projectq.setups.ibm.get_engine_list())
      7 
----> 8 circuito1(1000)

<ipython-input-4-93564acd1793> in circuito1(numEjecuciones)
      4     for _ in range(numEjecuciones):
      5 
----> 6         q = hello_entangled_world(eng)
      7         valor = str(int(q[0])) + str(int(q[1]))
      8         resultados[valor] += 1

<ipython-input-3-100a33bbd4c7> in hello_entangled_world(eng)
     11     All(Measure) | q
     12 
---> 13     eng.flush()
     14 
     15     return q

/opt/anaconda3/lib/python3.7/site-packages/projectq/cengines/_main.py in flush(self, deallocate_qubits)
    302                 qb = self.active_qubits.pop()
    303                 qb.__del__()
--> 304         self.receive([Command(self, FlushGate(), ([WeakQubitRef(self, -1)],))])

/opt/anaconda3/lib/python3.7/site-packages/projectq/cengines/_main.py in receive(self, command_list)
    264                 then send on)
    265         """
--> 266         self.send(command_list)
    267 
    268     def send(self, command_list):

/opt/anaconda3/lib/python3.7/site-packages/projectq/cengines/_main.py in send(self, command_list)
    286                                              "\n" + repr(last_line[-2]))
    287                 compact_exception.__cause__ = None
--> 288                 raise compact_exception  # use verbose=True for more info
    289 
    290     def flush(self, deallocate_qubits=False):

DeviceOfflineError: Device is offline.
 raised in:
'  File "/opt/anaconda3/lib/python3.7/site-packages/projectq/backends/_ibm/_ibm_http_client.py", line 79, in send'
'    raise DeviceOfflineError("Device is offline.")'

4) Accediendo directamente a la función de onda, calcula las amplitudes y las probabilidades de cada uno de los estados de la base computacional.

def hello_entangled_world(eng):

    

    q = eng.allocate_qureg(2)

        

    H | q[0]

    CNOT | (q[0], q[1])

    

    for val in ['0','1']:

        amp[val]  = eng.backend.get_amplitude(val,q)

        probq0[val] = eng.backend.get_probability(val,q[0])

        probq1[val] = eng.backend.get_probability(val,q[1])

    

    All(Measure) | q

    

    eng.flush()

    

    return q

    

eng = projectq.MainEngine()

​

circuito1(1000)

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-6-945eee377120> in <module>
     19 eng = projectq.MainEngine()
     20 
---> 21 circuito1(1000)

<ipython-input-4-93564acd1793> in circuito1(numEjecuciones)
      4     for _ in range(numEjecuciones):
      5 
----> 6         q = hello_entangled_world(eng)
      7         valor = str(int(q[0])) + str(int(q[1]))
      8         resultados[valor] += 1

<ipython-input-6-945eee377120> in hello_entangled_world(eng)
      7 
      8     for val in ['0','1']:
----> 9         amp[val]  = eng.backend.get_amplitude(val,q)
     10         probq0[val] = eng.backend.get_probability(val,q[0])
     11         probq1[val] = eng.backend.get_probability(val,q[1])

NameError: name 'amp' is not defined

5) ¿Crees que podrías diseñar un circuito que entrelazara 3 qubits de forma que su estado fuera 12√(|000⟩+|111⟩)

?

​

6) Comprueba la siguiente equivalencia de puertas
𝑍=𝐻𝑋𝐻

Para ello, ten en cuenta que es necesario y suficiente comprobar que dan el mismo resultado (obtienen el mismo estado, no sólo las mismas probabilidades) para los valores iniciales del qubit |0⟩
y |1⟩

.

​

7) Comprueba también la siguiente equivalencia de puertas
𝑆†=𝑆𝑆𝑆

​

8) ¿Qué función calcula el circuito de la figura? Ten en cuenta que ahora hay cuatro posibles valores iniciales para los qubits: |00⟩,|01⟩,|10⟩
y |11⟩

.

​

9) Determina qué función es calculada por el circuito de la figura. De nuevo, hay cuatro posibles valores iniciales para los qubits.

​

10) Comprueba que el circuito de la figura es equivalente a una puerta de Toffoli (ahora el número de posibles valores inciales que debes comprobar es 8, porque hay tres qubits).

​

11) Crea un circuito con una sola puerta de Toffoli. Si lo lanzas a ejecutar en IBM Quantum Experience, ¿en qué puertas se transforma?

​

12) Comprobemos los límites del simulador de ProjectQ. Crea una función que reciba un parámetro 𝑛
entero y cree un circuito en el que se aplica la puerta 𝐻 a cada uno de los qubits y luego se aplica la puerta 𝐶𝑁𝑂𝑇 a cada par de qubits consecutivos. Finalmente, se miden todos los qubits. ¿Cuál es el mayor 𝑛

para el que se puede ejecutar el circuito en el simulador?

​


